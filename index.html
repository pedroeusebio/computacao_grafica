<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Space Cubes </title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="three.js"></script>
    <script src="Second_Work/OrbitControls.js"></script>
    <script>
      var camera, scene, renderer, raycaster;
      var width, height;
      var mouse = new THREE.Vector2(), INTERSECTED;
      var intersects;
      init();
      render();
      
      function init(){
        width = window.innerWidth;
        height =  window.innerHeight;
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xeeeeee);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 500;
        camera.zoom = 5;
        
        var light = new THREE.DirectionalLight( 0xffffff, 1 );
        light.position.set( 1, 1, 1 ).normalize();
        scene.add( light );

        raycaster = new THREE.Raycaster();
        
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        
        renderer.domElement.addEventListener("click", createCube);
        document.addEventListener( 'mousemove', OnmouseMove, false );
      
      }
      function render() {
        requestAnimationFrame( render );
        
        //find intersection
        
        raycaster.setFromCamera(mouse,camera);
        
        intersects = raycaster.intersectObjects(scene.children);
        console.log(intersects.length);
        if (intersects.length > 0 ){
          if (INTERSECTED != intersects[0].object){
            if (INTERSECTED) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}
        renderer.render(scene, camera);
        controls.update();
      }
      
      function createCube (){
        if (intersects.length > 0 ) return 0;
        
         var event = window.event;
         var x = event.clientX;
         var y = event.clientY;
         
         var geometry = new THREE.BoxGeometry(100,100,100);
         var material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
         var cube = new THREE.Mesh( geometry, material );
         var vector = new THREE.Vector3();
         vector.set((x/width)*2 -1,-(y/height)*2 +1, 0);
         vector.unproject( camera );
         var dir = vector.sub(camera.position).normalize();
         var distance = - camera.position.z/dir.z;
         var pos = camera.position.clone().add(dir.multiplyScalar(distance));
         
         
         cube.position.set(pos.x,pos.y,pos.z);
         scene.add( cube );
       }
      function OnmouseMove( event ){
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY/window.innerHeight) * 2 + 1; 
      }
      
    </script>
  </body>
</html>
