<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Space Cubes </title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="three.js"></script>
    <script src="Second_Work/OrbitControls.js"></script>
    <script>
      var camera, scene, renderer, raycaster, plane;
      var width, height;
      var mouse = new THREE.Vector2(), INTERSECTED;
      var intersects;
      var transperanceCube;
      var selection;
      var offset = new THREE.Vector3();
      init();
      render();
      
      function init(){
        //initializing scene
        width = window.innerWidth;
        height =  window.innerHeight;
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
        camera.lookAt(new THREE.Vector3(0,0,0));
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xeeeeee);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 500;
        camera.zoom = 5;
        
        //adding light to the scene
        var light = new THREE.AmbientLight( 0xffffff );
        //light.position.set( 1, 1, 1 ).normalize();
        scene.add( light );
        
        //creating a raycaster
        raycaster = new THREE.Raycaster();
        
        //adding listener for events
        renderer.domElement.addEventListener("contextmenu", createCube);
        document.addEventListener( 'mousemove', OnmouseMove, false );
        document.addEventListener('click',OncubeClick,false);
        document.addEventListener('mousedown',OnDragCube,false);
        document.addEventListener('mouseup',OnRealizeCube,false);
        
        //creating a orbit controler for the renderer
        controls = new THREE.OrbitControls(this.camera);
        this.controls.target = new THREE.Vector3(0, 0, 0);
        
        // 
        
        plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(500, 500,0), new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 1}));
        scene.add(plane);
        plane.visible = true;
        


      
      }
      function render() {
        requestAnimationFrame( render );
        
        //find intersection
        
        raycaster.setFromCamera(mouse,camera);
        
        intersects = raycaster.intersectObjects(scene.children);

        renderer.render(scene, camera);
        controls.update();
      }
      
      function createCube (){
        if (intersects.length > 0 ) return 0;
        var event = window.event;
        event.preventDefault();
        var x = event.clientX;
        var y = event.clientY;
         
        var geometry = new THREE.BoxGeometry(100,100,100,1,1);
        var material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
        var cube = new THREE.Mesh( geometry, material );
        var vector = new THREE.Vector3();
        vector.set((x/width)*2 -1,-(y/height)*2 +1, 0);
        vector.unproject( camera );
        var dir = vector.sub(camera.position).normalize();
        var distance = - camera.position.z/dir.z;
        var pos = camera.position.clone().add(dir.multiplyScalar(distance));
         
         
        cube.position.set(pos.x,pos.y,pos.z);
        console.log(pos.z);
        scene.add( cube );
         
       }
      
      function OnmouseMove( event ){
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY/window.innerHeight) * 2 + 1; 

        if(selection){
          var intersect = raycaster.intersectObject(plane);
          selection.position.copy(intersect[0].point.sub(offset));
          scene.getObjectByName("selected").position.copy(selection.position);
        } /*else {
          var intersect = raycaster.intersectObjects(scene.children);
          if (intersect.length > 0 ){
            plane.position.copy(intersect[0].object.position);
            plane.lookAt(camera.position);
          }
        }*/
      }
      
      function OncubeClick( event ){
        scene.remove(transperanceCube);
        
        if(scene.getObjectByName("selected")) scene.getObjectByName("selected").name = "";
        
        if(intersects.length > 0 ){
          var cube = intersects[0].object;
          cube.name = "selected";
          transperanceCube = new THREE.Mesh( new THREE.BoxGeometry(110,110,110,1,1), new THREE.MeshLambertMaterial({color : 0xffffff, transparent :true, opacity: 0.4}));
          transperanceCube.name = "selector";
          scene.add(transperanceCube);
          transperanceCube.position.set(cube.position.x, cube.position.y, cube.position.z);
          plane.position.copy(cube.position);
          plane.lookAt(camera.position);
        }
      }
      
      
      function OnDragCube( event ){
        event.preventDefault();
        if (intersects.length >0 ){
          controls.enabled = false;
          selection = intersects[0].object;
          var intersect = raycaster.intersectObject(plane);
          console.log(intersect);
          offset.copy(intersect[0].point).sub(plane.position);
          console.log(selection);
        }
      }
      
      
      function OnRealizeCube (event) {
        controls.enabled = true;
        selection = null;
        plane.position.set(width,height,0);

      }
      
    </script>
  </body>
</html>
